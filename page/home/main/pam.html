<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PAM - Pattaya Aviation Management System</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Shared CSS -->
    <link rel="stylesheet" href="../../../function/shared/css/fonts.css">

    <!-- User Portal CSS -->
    <link rel="stylesheet" href="../../../function/home/css/user-base.css">

    <style>
        #fluid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
            display: block;
        }

        body>*:not(#fluid) {
            position: relative;
            z-index: 1;
        }
    </style>
</head>

<body class="min-h-screen flex items-center justify-center p-6 lg:p-12 pt-24 lg:pt-20">

    <!-- Fluid Canvas -->
    <canvas id="fluid"></canvas>

    <!-- Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="../../../function/shared/js/supabase-config.js"></script>

    <!-- Navbar Component -->
    <div id="navbar-container"></div>
    <script src="../../../function/home/components/navbar.js"></script>

    <!-- Main Container -->
    <div class="w-full flex items-center justify-center">
        <div class="text-center">
            <h1 class="text-6xl lg:text-9xl font-bold text-gray-900">PAM</h1>
            <p class="text-2xl lg:text-4xl text-blue-500 mt-4 lg:mt-8">Pattaya Aviation Management System</p>
        </div>
    </div>

    <!-- SplashCursor Fluid Simulation -->
    <script>
        (function () {
            const canvas = document.getElementById('fluid');
            if (!canvas) return;

            const config = {
                SIM_RESOLUTION: 128,
                DYE_RESOLUTION: 1440,
                DENSITY_DISSIPATION: 3.5,
                VELOCITY_DISSIPATION: 2,
                PRESSURE: 0.1,
                PRESSURE_ITERATIONS: 20,
                CURL: 3,
                SPLAT_RADIUS: 0.2,
                SPLAT_FORCE: 6000,
                SHADING: true,
                COLOR_UPDATE_SPEED: 10,
                TRANSPARENT: true,
            };

            function pointerPrototype() {
                this.id = -1;
                this.texcoordX = 0; this.texcoordY = 0;
                this.prevTexcoordX = 0; this.prevTexcoordY = 0;
                this.deltaX = 0; this.deltaY = 0;
                this.down = false; this.moved = false;
                this.color = [0, 0, 0];
            }
            let pointers = [new pointerPrototype()];

            // ── WebGL context ────────────────────────────────────────
            const params = { alpha: true, depth: false, stencil: false, antialias: false, preserveDrawingBuffer: false };
            let gl = canvas.getContext('webgl2', params);
            const isWebGL2 = !!gl;
            if (!isWebGL2) gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);

            let halfFloat, supportLinearFiltering;
            if (isWebGL2) {
                gl.getExtension('EXT_color_buffer_float');
                supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
            } else {
                halfFloat = gl.getExtension('OES_texture_half_float');
                supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
            }
            if (!supportLinearFiltering) { config.DYE_RESOLUTION = 256; config.SHADING = false; }

            gl.clearColor(0, 0, 0, 1);
            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;

            function getSupportedFormat(gl, internalFormat, format, type) {
                if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
                    if (internalFormat === gl.R16F) return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                    if (internalFormat === gl.RG16F) return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                    return null;
                }
                return { internalFormat, format };
            }
            function supportRenderTextureFormat(gl, internalFormat, format, type) {
                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                return gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
            }

            let formatRGBA, formatRG, formatR;
            if (isWebGL2) {
                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
            } else {
                formatRGBA = formatRG = formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
            }
            const ext = { formatRGBA, formatRG, formatR, halfFloatTexType, supportLinearFiltering };

            // ── Shader helpers ───────────────────────────────────────
            function compileShader(type, source, keywords) {
                if (keywords) source = keywords.map(k => '#define ' + k + '\n').join('') + source;
                const s = gl.createShader(type);
                gl.shaderSource(s, source); gl.compileShader(s);
                return s;
            }
            function createProgram(vs, fs) {
                const p = gl.createProgram();
                gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
                return p;
            }
            function getUniforms(program) {
                const u = {};
                const count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (let i = 0; i < count; i++) {
                    const name = gl.getActiveUniform(program, i).name;
                    u[name] = gl.getUniformLocation(program, name);
                }
                return u;
            }
            function hashCode(s) {
                let h = 0;
                for (let i = 0; i < s.length; i++) { h = (h << 5) - h + s.charCodeAt(i); h |= 0; }
                return h;
            }

            class Material {
                constructor(vs, fsSource) {
                    this.vs = vs; this.fsSource = fsSource;
                    this.programs = {}; this.activeProgram = null; this.uniforms = {};
                }
                setKeywords(keywords) {
                    const hash = keywords.reduce((h, k) => h + hashCode(k), 0);
                    if (!this.programs[hash]) {
                        const fs = compileShader(gl.FRAGMENT_SHADER, this.fsSource, keywords);
                        this.programs[hash] = createProgram(this.vs, fs);
                    }
                    if (this.programs[hash] === this.activeProgram) return;
                    this.activeProgram = this.programs[hash];
                    this.uniforms = getUniforms(this.activeProgram);
                }
                bind() { gl.useProgram(this.activeProgram); }
            }
            class Program {
                constructor(vs, fs) {
                    this.program = createProgram(vs, fs);
                    this.uniforms = getUniforms(this.program);
                }
                bind() { gl.useProgram(this.program); }
            }

            // ── Base vertex shader ───────────────────────────────────
            const baseVS = compileShader(gl.VERTEX_SHADER, `
            precision highp float;
            attribute vec2 aPosition;
            varying vec2 vUv, vL, vR, vT, vB;
            uniform vec2 texelSize;
            void main(){
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `);

            const copyProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv; uniform sampler2D uTexture; void main(){ gl_FragColor = texture2D(uTexture, vUv); }`));
            const clearProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv; uniform sampler2D uTexture; uniform float value; void main(){ gl_FragColor = value * texture2D(uTexture, vUv); }`));
            const splatProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D uTarget; uniform float aspectRatio; uniform vec3 color; uniform vec2 point; uniform float radius; void main(){ vec2 p = vUv - point.xy; p.x *= aspectRatio; vec3 splat = exp(-dot(p,p)/radius)*color; vec3 base = texture2D(uTarget,vUv).xyz; gl_FragColor = vec4(base+splat,1.0); }`));
            const advectionProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D uVelocity, uSource; uniform vec2 texelSize, dyeTexelSize; uniform float dt, dissipation;
            vec4 bilerp(sampler2D sam, vec2 uv, vec2 tsize){ vec2 st=uv/tsize-0.5; vec2 iuv=floor(st); vec2 fuv=fract(st); vec4 a=texture2D(sam,(iuv+vec2(0.5,0.5))*tsize); vec4 b=texture2D(sam,(iuv+vec2(1.5,0.5))*tsize); vec4 c=texture2D(sam,(iuv+vec2(0.5,1.5))*tsize); vec4 d=texture2D(sam,(iuv+vec2(1.5,1.5))*tsize); return mix(mix(a,b,fuv.x),mix(c,d,fuv.x),fuv.y); }
            void main(){ vec2 coord=vUv-dt*texture2D(uVelocity,vUv).xy*texelSize; vec4 result=texture2D(uSource,coord); float decay=1.0+dissipation*dt; gl_FragColor=result/decay; }`,
                ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']));
            const divergenceProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uVelocity; void main(){ float L=texture2D(uVelocity,vL).x,R=texture2D(uVelocity,vR).x,T=texture2D(uVelocity,vT).y,B=texture2D(uVelocity,vB).y; vec2 C=texture2D(uVelocity,vUv).xy; if(vL.x<0.0)L=-C.x; if(vR.x>1.0)R=-C.x; if(vT.y>1.0)T=-C.y; if(vB.y<0.0)B=-C.y; gl_FragColor=vec4(0.5*(R-L+T-B),0,0,1); }`));
            const curlProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uVelocity; void main(){ float L=texture2D(uVelocity,vL).y,R=texture2D(uVelocity,vR).y,T=texture2D(uVelocity,vT).x,B=texture2D(uVelocity,vB).x; gl_FragColor=vec4(0.5*(R-L-T+B),0,0,1); }`));
            const vorticityProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision highp float; precision highp sampler2D; varying vec2 vUv,vL,vR,vT,vB; uniform sampler2D uVelocity,uCurl; uniform float curl,dt; void main(){ float L=texture2D(uCurl,vL).x,R=texture2D(uCurl,vR).x,T=texture2D(uCurl,vT).x,B=texture2D(uCurl,vB).x,C=texture2D(uCurl,vUv).x; vec2 force=0.5*vec2(abs(T)-abs(B),abs(R)-abs(L)); force/=length(force)+0.0001; force*=curl*C; force.y*=-1.0; vec2 vel=texture2D(uVelocity,vUv).xy+force*dt; gl_FragColor=vec4(min(max(vel,-1000.0),1000.0),0,1); }`));
            const pressureProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uPressure,uDivergence; void main(){ float L=texture2D(uPressure,vL).x,R=texture2D(uPressure,vR).x,T=texture2D(uPressure,vT).x,B=texture2D(uPressure,vB).x,div=texture2D(uDivergence,vUv).x; gl_FragColor=vec4((L+R+B+T-div)*0.25,0,0,1); }`));
            const gradSubProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uPressure,uVelocity; void main(){ float L=texture2D(uPressure,vL).x,R=texture2D(uPressure,vR).x,T=texture2D(uPressure,vT).x,B=texture2D(uPressure,vB).x; vec2 vel=texture2D(uVelocity,vUv).xy-vec2(R-L,T-B); gl_FragColor=vec4(vel,0,1); }`));

            const displayMaterial = new Material(baseVS, `
            precision highp float; precision highp sampler2D;
            varying vec2 vUv, vL, vR, vT, vB;
            uniform sampler2D uTexture; uniform vec2 texelSize;
            vec3 linearToGamma(vec3 c){ return max(1.055*pow(max(c,vec3(0)),vec3(0.4166))-0.055,vec3(0)); }
            void main(){
                vec3 c = texture2D(uTexture, vUv).rgb;
                #ifdef SHADING
                    vec3 lc=texture2D(uTexture,vL).rgb, rc=texture2D(uTexture,vR).rgb;
                    vec3 tc=texture2D(uTexture,vT).rgb, bc=texture2D(uTexture,vB).rgb;
                    float dx=length(rc)-length(lc), dy=length(tc)-length(bc);
                    vec3 n=normalize(vec3(dx,dy,length(texelSize)));
                    c *= clamp(dot(n,vec3(0,0,1))+0.7, 0.7, 1.0);
                #endif
                float a = max(c.r, max(c.g, c.b));
                gl_FragColor = vec4(c, a);
            }
        `);

            // ── Blit quad ────────────────────────────────────────────
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);

            function blit(target, clear = false) {
                if (target == null) {
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                } else {
                    gl.viewport(0, 0, target.width, target.height);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
                }
                if (clear) { gl.clearColor(0, 0, 0, 1); gl.clear(gl.COLOR_BUFFER_BIT); }
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }

            // ── FBO helpers ──────────────────────────────────────────
            function createFBO(w, h, internalFormat, format, type, param) {
                gl.activeTexture(gl.TEXTURE0);
                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                gl.viewport(0, 0, w, h); gl.clear(gl.COLOR_BUFFER_BIT);
                return {
                    texture: tex, fbo, width: w, height: h,
                    texelSizeX: 1 / w, texelSizeY: 1 / h,
                    attach(id) { gl.activeTexture(gl.TEXTURE0 + id); gl.bindTexture(gl.TEXTURE_2D, tex); return id; }
                };
            }
            function createDoubleFBO(w, h, iF, f, type, param) {
                let a = createFBO(w, h, iF, f, type, param), b = createFBO(w, h, iF, f, type, param);
                return {
                    width: w, height: h, texelSizeX: a.texelSizeX, texelSizeY: a.texelSizeY,
                    get read() { return a; }, set read(v) { a = v; },
                    get write() { return b; }, set write(v) { b = v; },
                    swap() { let t = a; a = b; b = t; }
                };
            }
            function resizeFBO(target, w, h, iF, f, type, param) {
                const n = createFBO(w, h, iF, f, type, param);
                copyProgram.bind();
                gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
                blit(n); return n;
            }
            function resizeDoubleFBO(target, w, h, iF, f, type, param) {
                if (target.width === w && target.height === h) return target;
                target.read = resizeFBO(target.read, w, h, iF, f, type, param);
                target.write = createFBO(w, h, iF, f, type, param);
                target.width = w; target.height = h;
                target.texelSizeX = 1 / w; target.texelSizeY = 1 / h;
                return target;
            }
            function getResolution(res) {
                let ar = gl.drawingBufferWidth / gl.drawingBufferHeight;
                if (ar < 1) ar = 1 / ar;
                const min = Math.round(res), max = Math.round(res * ar);
                return gl.drawingBufferWidth > gl.drawingBufferHeight ? { width: max, height: min } : { width: min, height: max };
            }
            function scaleByPixelRatio(v) { return Math.floor(v * (window.devicePixelRatio || 1)); }

            let dye, velocity, divergence, curl, pressure;
            function initFBOs() {
                const simRes = getResolution(config.SIM_RESOLUTION);
                const dyeRes = getResolution(config.DYE_RESOLUTION);
                const { halfFloatTexType: T, formatRGBA: rgba, formatRG: rg, formatR: r } = ext;
                const filt = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
                gl.disable(gl.BLEND);
                dye = dye ? resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, T, filt)
                    : createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, T, filt);
                velocity = velocity ? resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, T, filt)
                    : createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, T, filt);
                divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, T, gl.NEAREST);
                curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, T, gl.NEAREST);
                pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, T, gl.NEAREST);
            }

            // ── Display keywords ─────────────────────────────────────
            displayMaterial.setKeywords(config.SHADING ? ['SHADING'] : []);
            initFBOs();

            // ── Color ────────────────────────────────────────────────
            function HSVtoRGB(h, s, v) {
                let r, g, b; const i = Math.floor(h * 6), f = h * 6 - i;
                const p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break; case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break;
                }
                return { r, g, b };
            }
            function generateColor() {
                const c = HSVtoRGB(Math.random(), 1, 1);
                return { r: c.r * 0.15, g: c.g * 0.15, b: c.b * 0.15 };
            }
            function correctRadius(r) {
                const ar = canvas.width / canvas.height;
                return ar > 1 ? r * ar : r;
            }
            function correctDeltaX(d) { const ar = canvas.width / canvas.height; return ar < 1 ? d * ar : d; }
            function correctDeltaY(d) { const ar = canvas.width / canvas.height; return ar > 1 ? d / ar : d; }

            function splat(x, y, dx, dy, color) {
                splatProgram.bind();
                gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
                gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
                gl.uniform2f(splatProgram.uniforms.point, x, y);
                gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0);
                gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100));
                blit(velocity.write); velocity.swap();
                gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
                gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
                blit(dye.write); dye.swap();
            }

            // ── Pointer helpers ──────────────────────────────────────
            function updatePointerDownData(p, id, posX, posY) {
                p.id = id; p.down = true; p.moved = false;
                p.texcoordX = posX / canvas.width; p.texcoordY = 1 - posY / canvas.height;
                p.prevTexcoordX = p.texcoordX; p.prevTexcoordY = p.texcoordY;
                p.deltaX = 0; p.deltaY = 0;
                p.color = generateColor();
            }
            function updatePointerMoveData(p, posX, posY, color) {
                p.prevTexcoordX = p.texcoordX; p.prevTexcoordY = p.texcoordY;
                p.texcoordX = posX / canvas.width; p.texcoordY = 1 - posY / canvas.height;
                p.deltaX = correctDeltaX(p.texcoordX - p.prevTexcoordX);
                p.deltaY = correctDeltaY(p.texcoordY - p.prevTexcoordY);
                p.moved = Math.abs(p.deltaX) > 0 || Math.abs(p.deltaY) > 0;
                p.color = color;
            }
            function updatePointerUpData(p) { p.down = false; }

            // ── Simulation step ──────────────────────────────────────
            function step(dt) {
                gl.disable(gl.BLEND);
                curlProgram.bind();
                gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
                blit(curl);
                vorticityProgram.bind();
                gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
                gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
                gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
                gl.uniform1f(vorticityProgram.uniforms.dt, dt);
                blit(velocity.write); velocity.swap();
                divergenceProgram.bind();
                gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
                blit(divergence);
                clearProgram.bind();
                gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
                gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
                blit(pressure.write); pressure.swap();
                pressureProgram.bind();
                gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
                for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                    gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
                    blit(pressure.write); pressure.swap();
                }
                gradSubProgram.bind();
                gl.uniform2f(gradSubProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(gradSubProgram.uniforms.uPressure, pressure.read.attach(0));
                gl.uniform1i(gradSubProgram.uniforms.uVelocity, velocity.read.attach(1));
                blit(velocity.write); velocity.swap();
                advectionProgram.bind();
                gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
                const vid = velocity.read.attach(0);
                gl.uniform1i(advectionProgram.uniforms.uVelocity, vid);
                gl.uniform1i(advectionProgram.uniforms.uSource, vid);
                gl.uniform1f(advectionProgram.uniforms.dt, dt);
                gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
                blit(velocity.write); velocity.swap();
                if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
                gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
                gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
                blit(dye.write); dye.swap();
            }

            function render() {
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.enable(gl.BLEND);
                const w = gl.drawingBufferWidth, h = gl.drawingBufferHeight;
                displayMaterial.bind();
                if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1 / w, 1 / h);
                gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
                blit(null);
            }

            // ── Event listeners ──────────────────────────────────────
            let firstMove = false;
            const p = pointers[0];
            window.addEventListener('mousedown', e => {
                const x = scaleByPixelRatio(e.clientX), y = scaleByPixelRatio(e.clientY);
                updatePointerDownData(p, -1, x, y);
                const c = generateColor(); c.r *= 10; c.g *= 10; c.b *= 10;
                splat(p.texcoordX, p.texcoordY, 10 * (Math.random() - 0.5), 30 * (Math.random() - 0.5), c);
            });
            window.addEventListener('mousemove', e => {
                const x = scaleByPixelRatio(e.clientX), y = scaleByPixelRatio(e.clientY);
                updatePointerMoveData(p, x, y, firstMove ? p.color : generateColor());
                firstMove = true;
            });
            window.addEventListener('touchstart', e => {
                const t = e.targetTouches[0];
                updatePointerDownData(p, t.identifier, scaleByPixelRatio(t.clientX), scaleByPixelRatio(t.clientY));
            });
            window.addEventListener('touchmove', e => {
                const t = e.targetTouches[0];
                updatePointerMoveData(p, scaleByPixelRatio(t.clientX), scaleByPixelRatio(t.clientY), p.color);
            }, { passive: true });
            window.addEventListener('touchend', () => updatePointerUpData(p));

            // ── Main loop ────────────────────────────────────────────
            let lastTime = Date.now(), colorTimer = 0;
            function updateFrame() {
                const now = Date.now();
                const dt = Math.min((now - lastTime) / 1000, 0.016666);
                lastTime = now;
                // Resize
                const w = scaleByPixelRatio(canvas.clientWidth), h = scaleByPixelRatio(canvas.clientHeight);
                if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; initFBOs(); }
                // Color cycle
                colorTimer += dt * config.COLOR_UPDATE_SPEED;
                if (colorTimer >= 1) { colorTimer -= 1; p.color = generateColor(); }
                // Apply input
                if (p.moved) { p.moved = false; splat(p.texcoordX, p.texcoordY, p.deltaX * config.SPLAT_FORCE, p.deltaY * config.SPLAT_FORCE, p.color); }
                step(dt);
                render();
                requestAnimationFrame(updateFrame);
            }
            requestAnimationFrame(updateFrame);
        })();
    </script>

</body>

</html>