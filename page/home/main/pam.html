<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PAM - Pattaya Aviation Management System</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Shared CSS -->
    <link rel="stylesheet" href="../../../function/shared/css/fonts.css">

    <!-- User Portal CSS -->
    <link rel="stylesheet" href="../../../function/home/css/user-base.css">

    <style>
        #fluid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
            display: block;
        }

        body>*:not(#fluid):not(#navbar-container) {
            position: relative;
            z-index: 1;
        }

        /* ── Login Card ───────────────────────────────────────── */
        .login-card {
            background: rgba(255, 255, 255, 0.72);
            backdrop-filter: blur(28px) saturate(160%);
            -webkit-backdrop-filter: blur(28px) saturate(160%);
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 2rem;
            box-shadow:
                0 8px 40px rgba(0, 0, 0, 0.10),
                0 2px 8px rgba(0, 0, 0, 0.06),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            animation: cardIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) both;
        }

        @keyframes cardIn {
            from {
                opacity: 0;
                transform: translateY(32px) scale(0.96);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .login-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 0.875rem;
            border: 1.5px solid rgba(209, 213, 219, 0.8);
            background: rgba(255, 255, 255, 0.55);
            font-size: 0.9rem;
            color: #111827;
            transition: border-color 0.2s, box-shadow 0.2s, background 0.2s;
            outline: none;
        }

        .login-input::placeholder {
            color: #9ca3af;
        }

        .login-input:focus {
            border-color: #3b82f6;
            background: rgba(255, 255, 255, 0.85);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .btn-primary {
            width: 100%;
            padding: 0.8rem 1rem;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            font-weight: 600;
            font-size: 0.95rem;
            border: none;
            border-radius: 0.875rem;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s, opacity 0.15s;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.35);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.45);
        }

        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.65;
            cursor: not-allowed;
            transform: none;
        }

        .btn-ms {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.85);
            color: #374151;
            font-weight: 500;
            font-size: 0.9rem;
            border: 1.5px solid rgba(209, 213, 219, 0.8);
            border-radius: 0.875rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.625rem;
            transition: background 0.15s, box-shadow 0.15s, transform 0.15s;
        }

        .btn-ms:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        .btn-ms:active {
            transform: translateY(0);
        }

        .divider {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: #9ca3af;
            font-size: 0.8rem;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(209, 213, 219, 0.6);
        }

        .login-wrapper {
            width: 100%;
            max-width: 420px;
            margin: 0 auto;
            padding: 0 1.5rem;
        }

        /* Alert messages */
        .alert {
            padding: 0.7rem 1rem;
            border-radius: 0.75rem;
            font-size: 0.85rem;
            text-align: center;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-4px)
            }

            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        .alert-error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
        }

        .alert-success {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: #16a34a;
        }

        .alert-info {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            color: #1d4ed8;
        }
    </style>
</head>

<body class="min-h-screen flex items-center justify-center p-6 lg:p-12 pt-24 lg:pt-20">

    <!-- Fluid Canvas -->
    <canvas id="fluid"></canvas>

    <!-- Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="../../../function/shared/js/supabase-config.js"></script>

    <!-- Navbar Component -->
    <div id="navbar-container"></div>
    <script src="../../../function/home/components/navbar.js"></script>

    <!-- Main Hero + Login Card -->
    <div class="w-full flex items-center justify-center">
        <div class="login-wrapper">

            <!-- Login Card -->
            <div>
                <div class="login-card p-7">
                    <!-- Header -->
                    <div class="mb-6">
                        <h2 class="text-xl font-bold text-gray-900">เข้าสู่ระบบ</h2>
                        <p class="text-sm text-gray-500 mt-1">ยินดีต้อนรับสู่ระบบ PAM</p>
                    </div>

                    <!-- Form -->
                    <form id="homeLoginForm" class="space-y-4" autocomplete="on">
                        <!-- Email -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1.5" for="homeEmail">อีเมล</label>
                            <input id="homeEmail" type="text" name="email" required class="login-input"
                                placeholder="example@pattayaaviation.com" autocomplete="username">
                        </div>

                        <!-- Password -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1.5"
                                for="homePassword">รหัสผ่าน</label>
                            <div class="relative">
                                <input id="homePassword" type="password" name="password" required
                                    class="login-input pr-11" placeholder="••••••••" autocomplete="current-password">
                                <button type="button" id="homeEyeBtn" onclick="toggleHomePassword()"
                                    class="absolute right-3.5 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600 transition-colors p-0.5"
                                    aria-label="แสดง/ซ่อนรหัสผ่าน">
                                    <svg id="homeEyeIcon" class="w-5 h-5" fill="none" stroke="currentColor"
                                        viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                                    </svg>
                                    <svg id="homeEyeOffIcon" class="w-5 h-5 hidden" fill="none" stroke="currentColor"
                                        viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Remember + Forgot -->
                        <div class="flex items-center justify-between">
                            <label class="flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" id="homeRemember"
                                    class="w-4 h-4 rounded border-gray-300 text-blue-500 accent-blue-500">
                                <span class="text-sm text-gray-600">จดจำฉัน</span>
                            </label>
                            <a href="#"
                                class="text-sm text-blue-500 hover:text-blue-600 transition-colors">ลืมรหัสผ่าน?</a>
                        </div>

                        <!-- Submit -->
                        <button type="submit" id="homeLoginBtn" class="btn-primary mt-1">
                            เข้าสู่ระบบ
                        </button>
                    </form>

                    <!-- Divider -->
                    <div class="divider my-5">หรือ</div>

                    <!-- Microsoft -->
                    <button class="btn-ms" onclick="signInWithMicrosoft()" id="homeMsBtn">
                        <svg width="18" height="18" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg">
                            <rect x="1" y="1" width="9" height="9" fill="#f25022" />
                            <rect x="11" y="1" width="9" height="9" fill="#7fba00" />
                            <rect x="1" y="11" width="9" height="9" fill="#00a4ef" />
                            <rect x="11" y="11" width="9" height="9" fill="#ffb900" />
                        </svg>
                        เข้าสู่ระบบด้วย Microsoft
                    </button>

                    <!-- Messages -->
                    <div id="homeErrorMsg" class="alert alert-error   hidden mt-4"></div>
                    <div id="homeSuccessMsg" class="alert alert-success hidden mt-4"></div>
                    <div id="homeInfoMsg" class="alert alert-info    hidden mt-4"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Home Login Logic -->
    <script>
        function toggleHomePassword() {
            const input = document.getElementById('homePassword');
            const eyeIcon = document.getElementById('homeEyeIcon');
            const eyeOffIcon = document.getElementById('homeEyeOffIcon');
            if (!input) return;
            if (input.type === 'password') {
                input.type = 'text';
                eyeIcon.classList.add('hidden');
                eyeOffIcon.classList.remove('hidden');
            } else {
                input.type = 'password';
                eyeIcon.classList.remove('hidden');
                eyeOffIcon.classList.add('hidden');
            }
        }

        function showHomeMsg(type, text) {
            ['homeErrorMsg', 'homeSuccessMsg', 'homeInfoMsg'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });
            const target = document.getElementById(
                type === 'error' ? 'homeErrorMsg' : type === 'success' ? 'homeSuccessMsg' : 'homeInfoMsg'
            );
            if (target) {
                target.textContent = text;
                target.classList.remove('hidden');
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const form = document.getElementById('homeLoginForm');
            if (!form) return;

            form.addEventListener('submit', async function (e) {
                e.preventDefault();

                const email = document.getElementById('homeEmail').value.trim();
                const password = document.getElementById('homePassword').value;
                const btn = document.getElementById('homeLoginBtn');

                btn.disabled = true;
                btn.textContent = 'กำลังเข้าสู่ระบบ...';

                // ── Dev shortcut ──────────────────────────────────────
                const IS_DEV = ['localhost', '127.0.0.1', '', 'main.d3pcpig1wsoers.amplifyapp.com']
                    .includes(window.location.hostname);

                if (IS_DEV && email === 'test' && password === '1234') {
                    sessionStorage.setItem('user', JSON.stringify({
                        name: 'Test Admin',
                        email: 'admin@pattayaaviation.com',
                        id: 'test-user-local'
                    }));

                    if (window.supabaseClient) {
                        await window.supabaseClient.auth.signInWithPassword({
                            email: 'admin@pattayaaviation.com',
                            password: 'PAMadmin2024!'
                        }).catch(() => { });
                    }

                    showHomeMsg('success', 'ยินดีต้อนรับ Test Admin!');
                    setTimeout(() => { window.location.href = '../../../page/portal/index.html'; }, 1200);
                    return;
                }

                // ── Normal: hint to use Microsoft ──────────────────────
                showHomeMsg('info', "กรุณาใช้ปุ่ม 'เข้าสู่ระบบด้วย Microsoft'");
                btn.disabled = false;
                btn.textContent = 'เข้าสู่ระบบ';
            });
        });
    </script>

    <!-- SplashCursor Fluid Simulation -->
    <script>
        (function () {
            const canvas = document.getElementById('fluid');
            if (!canvas) return;

            const config = {
                SIM_RESOLUTION: 128,
                DYE_RESOLUTION: 1440,
                DENSITY_DISSIPATION: 3.5,
                VELOCITY_DISSIPATION: 2,
                PRESSURE: 0.1,
                PRESSURE_ITERATIONS: 20,
                CURL: 3,
                SPLAT_RADIUS: 0.2,
                SPLAT_FORCE: 6000,
                SHADING: true,
                COLOR_UPDATE_SPEED: 10,
                TRANSPARENT: true,
            };

            function pointerPrototype() {
                this.id = -1;
                this.texcoordX = 0; this.texcoordY = 0;
                this.prevTexcoordX = 0; this.prevTexcoordY = 0;
                this.deltaX = 0; this.deltaY = 0;
                this.down = false; this.moved = false;
                this.color = [0, 0, 0];
            }
            let pointers = [new pointerPrototype()];

            // ── WebGL context ────────────────────────────────────────
            const params = { alpha: true, depth: false, stencil: false, antialias: false, preserveDrawingBuffer: false };
            let gl = canvas.getContext('webgl2', params);
            const isWebGL2 = !!gl;
            if (!isWebGL2) gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);

            let halfFloat, supportLinearFiltering;
            if (isWebGL2) {
                gl.getExtension('EXT_color_buffer_float');
                supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
            } else {
                halfFloat = gl.getExtension('OES_texture_half_float');
                supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
            }
            if (!supportLinearFiltering) { config.DYE_RESOLUTION = 256; config.SHADING = false; }

            gl.clearColor(0, 0, 0, 1);
            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;

            function getSupportedFormat(gl, internalFormat, format, type) {
                if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
                    if (internalFormat === gl.R16F) return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                    if (internalFormat === gl.RG16F) return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                    return null;
                }
                return { internalFormat, format };
            }
            function supportRenderTextureFormat(gl, internalFormat, format, type) {
                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                return gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
            }

            let formatRGBA, formatRG, formatR;
            if (isWebGL2) {
                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
            } else {
                formatRGBA = formatRG = formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
            }
            const ext = { formatRGBA, formatRG, formatR, halfFloatTexType, supportLinearFiltering };

            // ── Shader helpers ───────────────────────────────────────
            function compileShader(type, source, keywords) {
                if (keywords) source = keywords.map(k => '#define ' + k + '\n').join('') + source;
                const s = gl.createShader(type);
                gl.shaderSource(s, source); gl.compileShader(s);
                return s;
            }
            function createProgram(vs, fs) {
                const p = gl.createProgram();
                gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
                return p;
            }
            function getUniforms(program) {
                const u = {};
                const count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (let i = 0; i < count; i++) {
                    const name = gl.getActiveUniform(program, i).name;
                    u[name] = gl.getUniformLocation(program, name);
                }
                return u;
            }
            function hashCode(s) {
                let h = 0;
                for (let i = 0; i < s.length; i++) { h = (h << 5) - h + s.charCodeAt(i); h |= 0; }
                return h;
            }

            class Material {
                constructor(vs, fsSource) {
                    this.vs = vs; this.fsSource = fsSource;
                    this.programs = {}; this.activeProgram = null; this.uniforms = {};
                }
                setKeywords(keywords) {
                    const hash = keywords.reduce((h, k) => h + hashCode(k), 0);
                    if (!this.programs[hash]) {
                        const fs = compileShader(gl.FRAGMENT_SHADER, this.fsSource, keywords);
                        this.programs[hash] = createProgram(this.vs, fs);
                    }
                    if (this.programs[hash] === this.activeProgram) return;
                    this.activeProgram = this.programs[hash];
                    this.uniforms = getUniforms(this.activeProgram);
                }
                bind() { gl.useProgram(this.activeProgram); }
            }
            class Program {
                constructor(vs, fs) {
                    this.program = createProgram(vs, fs);
                    this.uniforms = getUniforms(this.program);
                }
                bind() { gl.useProgram(this.program); }
            }

            // ── Base vertex shader ───────────────────────────────────
            const baseVS = compileShader(gl.VERTEX_SHADER, `
            precision highp float;
            attribute vec2 aPosition;
            varying vec2 vUv, vL, vR, vT, vB;
            uniform vec2 texelSize;
            void main(){
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `);

            const copyProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv; uniform sampler2D uTexture; void main(){ gl_FragColor = texture2D(uTexture, vUv); }`));
            const clearProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv; uniform sampler2D uTexture; uniform float value; void main(){ gl_FragColor = value * texture2D(uTexture, vUv); }`));
            const splatProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D uTarget; uniform float aspectRatio; uniform vec3 color; uniform vec2 point; uniform float radius; void main(){ vec2 p = vUv - point.xy; p.x *= aspectRatio; vec3 splat = exp(-dot(p,p)/radius)*color; vec3 base = texture2D(uTarget,vUv).xyz; gl_FragColor = vec4(base+splat,1.0); }`));
            const advectionProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D uVelocity, uSource; uniform vec2 texelSize, dyeTexelSize; uniform float dt, dissipation;
            vec4 bilerp(sampler2D sam, vec2 uv, vec2 tsize){ vec2 st=uv/tsize-0.5; vec2 iuv=floor(st); vec2 fuv=fract(st); vec4 a=texture2D(sam,(iuv+vec2(0.5,0.5))*tsize); vec4 b=texture2D(sam,(iuv+vec2(1.5,0.5))*tsize); vec4 c=texture2D(sam,(iuv+vec2(0.5,1.5))*tsize); vec4 d=texture2D(sam,(iuv+vec2(1.5,1.5))*tsize); return mix(mix(a,b,fuv.x),mix(c,d,fuv.x),fuv.y); }
            void main(){ vec2 coord=vUv-dt*texture2D(uVelocity,vUv).xy*texelSize; vec4 result=texture2D(uSource,coord); float decay=1.0+dissipation*dt; gl_FragColor=result/decay; }`,
                ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']));
            const divergenceProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uVelocity; void main(){ float L=texture2D(uVelocity,vL).x,R=texture2D(uVelocity,vR).x,T=texture2D(uVelocity,vT).y,B=texture2D(uVelocity,vB).y; vec2 C=texture2D(uVelocity,vUv).xy; if(vL.x<0.0)L=-C.x; if(vR.x>1.0)R=-C.x; if(vT.y>1.0)T=-C.y; if(vB.y<0.0)B=-C.y; gl_FragColor=vec4(0.5*(R-L+T-B),0,0,1); }`));
            const curlProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uVelocity; void main(){ float L=texture2D(uVelocity,vL).y,R=texture2D(uVelocity,vR).y,T=texture2D(uVelocity,vT).x,B=texture2D(uVelocity,vB).x; gl_FragColor=vec4(0.5*(R-L-T+B),0,0,1); }`));
            const vorticityProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision highp float; precision highp sampler2D; varying vec2 vUv,vL,vR,vT,vB; uniform sampler2D uVelocity,uCurl; uniform float curl,dt; void main(){ float L=texture2D(uCurl,vL).x,R=texture2D(uCurl,vR).x,T=texture2D(uCurl,vT).x,B=texture2D(uCurl,vB).x,C=texture2D(uCurl,vUv).x; vec2 force=0.5*vec2(abs(T)-abs(B),abs(R)-abs(L)); force/=length(force)+0.0001; force*=curl*C; force.y*=-1.0; vec2 vel=texture2D(uVelocity,vUv).xy+force*dt; gl_FragColor=vec4(min(max(vel,-1000.0),1000.0),0,1); }`));
            const pressureProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uPressure,uDivergence; void main(){ float L=texture2D(uPressure,vL).x,R=texture2D(uPressure,vR).x,T=texture2D(uPressure,vT).x,B=texture2D(uPressure,vB).x,div=texture2D(uDivergence,vUv).x; gl_FragColor=vec4((L+R+B+T-div)*0.25,0,0,1); }`));
            const gradSubProgram = new Program(baseVS, compileShader(gl.FRAGMENT_SHADER, `precision mediump float; precision mediump sampler2D; varying highp vec2 vUv,vL,vR,vT,vB; uniform sampler2D uPressure,uVelocity; void main(){ float L=texture2D(uPressure,vL).x,R=texture2D(uPressure,vR).x,T=texture2D(uPressure,vT).x,B=texture2D(uPressure,vB).x; vec2 vel=texture2D(uVelocity,vUv).xy-vec2(R-L,T-B); gl_FragColor=vec4(vel,0,1); }`));

            const displayMaterial = new Material(baseVS, `
            precision highp float; precision highp sampler2D;
            varying vec2 vUv, vL, vR, vT, vB;
            uniform sampler2D uTexture; uniform vec2 texelSize;
            vec3 linearToGamma(vec3 c){ return max(1.055*pow(max(c,vec3(0)),vec3(0.4166))-0.055,vec3(0)); }
            void main(){
                vec3 c = texture2D(uTexture, vUv).rgb;
                #ifdef SHADING
                    vec3 lc=texture2D(uTexture,vL).rgb, rc=texture2D(uTexture,vR).rgb;
                    vec3 tc=texture2D(uTexture,vT).rgb, bc=texture2D(uTexture,vB).rgb;
                    float dx=length(rc)-length(lc), dy=length(tc)-length(bc);
                    vec3 n=normalize(vec3(dx,dy,length(texelSize)));
                    c *= clamp(dot(n,vec3(0,0,1))+0.7, 0.7, 1.0);
                #endif
                float a = max(c.r, max(c.g, c.b));
                gl_FragColor = vec4(c, a);
            }
        `);

            // ── Blit quad ────────────────────────────────────────────
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);

            function blit(target, clear = false) {
                if (target == null) {
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                } else {
                    gl.viewport(0, 0, target.width, target.height);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
                }
                if (clear) { gl.clearColor(0, 0, 0, 1); gl.clear(gl.COLOR_BUFFER_BIT); }
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }

            // ── FBO helpers ──────────────────────────────────────────
            function createFBO(w, h, internalFormat, format, type, param) {
                gl.activeTexture(gl.TEXTURE0);
                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                gl.viewport(0, 0, w, h); gl.clear(gl.COLOR_BUFFER_BIT);
                return {
                    texture: tex, fbo, width: w, height: h,
                    texelSizeX: 1 / w, texelSizeY: 1 / h,
                    attach(id) { gl.activeTexture(gl.TEXTURE0 + id); gl.bindTexture(gl.TEXTURE_2D, tex); return id; }
                };
            }
            function createDoubleFBO(w, h, iF, f, type, param) {
                let a = createFBO(w, h, iF, f, type, param), b = createFBO(w, h, iF, f, type, param);
                return {
                    width: w, height: h, texelSizeX: a.texelSizeX, texelSizeY: a.texelSizeY,
                    get read() { return a; }, set read(v) { a = v; },
                    get write() { return b; }, set write(v) { b = v; },
                    swap() { let t = a; a = b; b = t; }
                };
            }
            function resizeFBO(target, w, h, iF, f, type, param) {
                const n = createFBO(w, h, iF, f, type, param);
                copyProgram.bind();
                gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
                blit(n); return n;
            }
            function resizeDoubleFBO(target, w, h, iF, f, type, param) {
                if (target.width === w && target.height === h) return target;
                target.read = resizeFBO(target.read, w, h, iF, f, type, param);
                target.write = createFBO(w, h, iF, f, type, param);
                target.width = w; target.height = h;
                target.texelSizeX = 1 / w; target.texelSizeY = 1 / h;
                return target;
            }
            function getResolution(res) {
                let ar = gl.drawingBufferWidth / gl.drawingBufferHeight;
                if (ar < 1) ar = 1 / ar;
                const min = Math.round(res), max = Math.round(res * ar);
                return gl.drawingBufferWidth > gl.drawingBufferHeight ? { width: max, height: min } : { width: min, height: max };
            }
            function scaleByPixelRatio(v) { return Math.floor(v * (window.devicePixelRatio || 1)); }

            let dye, velocity, divergence, curl, pressure;
            function initFBOs() {
                const simRes = getResolution(config.SIM_RESOLUTION);
                const dyeRes = getResolution(config.DYE_RESOLUTION);
                const { halfFloatTexType: T, formatRGBA: rgba, formatRG: rg, formatR: r } = ext;
                const filt = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
                gl.disable(gl.BLEND);
                dye = dye ? resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, T, filt)
                    : createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, T, filt);
                velocity = velocity ? resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, T, filt)
                    : createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, T, filt);
                divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, T, gl.NEAREST);
                curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, T, gl.NEAREST);
                pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, T, gl.NEAREST);
            }

            // ── Display keywords ─────────────────────────────────────
            displayMaterial.setKeywords(config.SHADING ? ['SHADING'] : []);
            initFBOs();

            // ── Color ────────────────────────────────────────────────
            function HSVtoRGB(h, s, v) {
                let r, g, b; const i = Math.floor(h * 6), f = h * 6 - i;
                const p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break; case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break;
                }
                return { r, g, b };
            }
            function generateColor() {
                const c = HSVtoRGB(Math.random(), 1, 1);
                return { r: c.r * 0.15, g: c.g * 0.15, b: c.b * 0.15 };
            }
            function correctRadius(r) {
                const ar = canvas.width / canvas.height;
                return ar > 1 ? r * ar : r;
            }
            function correctDeltaX(d) { const ar = canvas.width / canvas.height; return ar < 1 ? d * ar : d; }
            function correctDeltaY(d) { const ar = canvas.width / canvas.height; return ar > 1 ? d / ar : d; }

            function splat(x, y, dx, dy, color) {
                splatProgram.bind();
                gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
                gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
                gl.uniform2f(splatProgram.uniforms.point, x, y);
                gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0);
                gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100));
                blit(velocity.write); velocity.swap();
                gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
                gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
                blit(dye.write); dye.swap();
            }

            // ── Pointer helpers ──────────────────────────────────────
            function updatePointerDownData(p, id, posX, posY) {
                p.id = id; p.down = true; p.moved = false;
                p.texcoordX = posX / canvas.width; p.texcoordY = 1 - posY / canvas.height;
                p.prevTexcoordX = p.texcoordX; p.prevTexcoordY = p.texcoordY;
                p.deltaX = 0; p.deltaY = 0;
                p.color = generateColor();
            }
            function updatePointerMoveData(p, posX, posY, color) {
                p.prevTexcoordX = p.texcoordX; p.prevTexcoordY = p.texcoordY;
                p.texcoordX = posX / canvas.width; p.texcoordY = 1 - posY / canvas.height;
                p.deltaX = correctDeltaX(p.texcoordX - p.prevTexcoordX);
                p.deltaY = correctDeltaY(p.texcoordY - p.prevTexcoordY);
                p.moved = Math.abs(p.deltaX) > 0 || Math.abs(p.deltaY) > 0;
                p.color = color;
            }
            function updatePointerUpData(p) { p.down = false; }

            // ── Simulation step ──────────────────────────────────────
            function step(dt) {
                gl.disable(gl.BLEND);
                curlProgram.bind();
                gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
                blit(curl);
                vorticityProgram.bind();
                gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
                gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
                gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
                gl.uniform1f(vorticityProgram.uniforms.dt, dt);
                blit(velocity.write); velocity.swap();
                divergenceProgram.bind();
                gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
                blit(divergence);
                clearProgram.bind();
                gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
                gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
                blit(pressure.write); pressure.swap();
                pressureProgram.bind();
                gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
                for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                    gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
                    blit(pressure.write); pressure.swap();
                }
                gradSubProgram.bind();
                gl.uniform2f(gradSubProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                gl.uniform1i(gradSubProgram.uniforms.uPressure, pressure.read.attach(0));
                gl.uniform1i(gradSubProgram.uniforms.uVelocity, velocity.read.attach(1));
                blit(velocity.write); velocity.swap();
                advectionProgram.bind();
                gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
                if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
                const vid = velocity.read.attach(0);
                gl.uniform1i(advectionProgram.uniforms.uVelocity, vid);
                gl.uniform1i(advectionProgram.uniforms.uSource, vid);
                gl.uniform1f(advectionProgram.uniforms.dt, dt);
                gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
                blit(velocity.write); velocity.swap();
                if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
                gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
                gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
                blit(dye.write); dye.swap();
            }

            function render() {
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.enable(gl.BLEND);
                const w = gl.drawingBufferWidth, h = gl.drawingBufferHeight;
                displayMaterial.bind();
                if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1 / w, 1 / h);
                gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
                blit(null);
            }

            // ── Event listeners ──────────────────────────────────────
            let firstMove = false;
            const p = pointers[0];
            window.addEventListener('mousedown', e => {
                const x = scaleByPixelRatio(e.clientX), y = scaleByPixelRatio(e.clientY);
                updatePointerDownData(p, -1, x, y);
                const c = generateColor(); c.r *= 10; c.g *= 10; c.b *= 10;
                splat(p.texcoordX, p.texcoordY, 10 * (Math.random() - 0.5), 30 * (Math.random() - 0.5), c);
            });
            window.addEventListener('mousemove', e => {
                const x = scaleByPixelRatio(e.clientX), y = scaleByPixelRatio(e.clientY);
                updatePointerMoveData(p, x, y, firstMove ? p.color : generateColor());
                firstMove = true;
            });
            window.addEventListener('touchstart', e => {
                const t = e.targetTouches[0];
                updatePointerDownData(p, t.identifier, scaleByPixelRatio(t.clientX), scaleByPixelRatio(t.clientY));
            });
            window.addEventListener('touchmove', e => {
                const t = e.targetTouches[0];
                updatePointerMoveData(p, scaleByPixelRatio(t.clientX), scaleByPixelRatio(t.clientY), p.color);
            }, { passive: true });
            window.addEventListener('touchend', () => updatePointerUpData(p));

            // ── Main loop ────────────────────────────────────────────
            let lastTime = Date.now(), colorTimer = 0;
            function updateFrame() {
                const now = Date.now();
                const dt = Math.min((now - lastTime) / 1000, 0.016666);
                lastTime = now;
                // Resize
                const w = scaleByPixelRatio(canvas.clientWidth), h = scaleByPixelRatio(canvas.clientHeight);
                if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; initFBOs(); }
                // Color cycle
                colorTimer += dt * config.COLOR_UPDATE_SPEED;
                if (colorTimer >= 1) { colorTimer -= 1; p.color = generateColor(); }
                // Apply input
                if (p.moved) { p.moved = false; splat(p.texcoordX, p.texcoordY, p.deltaX * config.SPLAT_FORCE, p.deltaY * config.SPLAT_FORCE, p.color); }
                step(dt);
                render();
                requestAnimationFrame(updateFrame);
            }
            requestAnimationFrame(updateFrame);
        })();
    </script>

</body>

</html>